#include <iostream>
#include "DataFormats/Candidate/interface/Candidate.h"
#include "DataFormats/HepMCCandidate/interface/GenParticle.h"
#include "SimDataFormats/GeneratorProducts/interface/HepMCProduct.h"
#include "SimDataFormats/GeneratorProducts/interface/GenEventInfoProduct.h"
#include "SimDataFormats/GeneratorProducts/interface/GenRunInfoProduct.h"

// essentials !!!
#include "FWCore/Framework/interface/Event.h"
#include "DataFormats/Common/interface/Handle.h"
#include "FWCore/Framework/interface/MakerMacros.h"

#include "FWCore/ServiceRegistry/interface/Service.h" 
#include "CommonTools/UtilAlgos/interface/TFileService.h"
#include "TH1.h"
#include "TTree.h"
#include "TObject.h"

#include "FWCore/Framework/interface/EDAnalyzer.h"

class Dstar_ccbar : public edm::EDAnalyzer
{

   public:
   
      //
      explicit Dstar_ccbar( const edm::ParameterSet& ) ;
      virtual ~Dstar_ccbar() {} // no need to delete ROOT stuff
                                   // as it'll be deleted upon closing TFile
      
      virtual void analyze( const edm::Event&, const edm::EventSetup& ) ;
      virtual void beginJob() ;
      virtual void endRun( const edm::Run&, const edm::EventSetup& ) ;
      virtual void endJob() ;

   private:
   
     TH1D*       dstarpt ;
     TH1D*       fHist4muMass ;
     TH1D*       fHistZZMass ;
     TTree *     decaytree;
     double      pt_dmeson;
     double      eta_paifromdstar;
     
}; 

using namespace edm;
using namespace std;
using namespace reco;

Dstar_ccbar::Dstar_ccbar( const ParameterSet& pset )
  : dstarpt(0), fHist4muMass(0), fHistZZMass(0)
{
// actually, pset is NOT in use - we keep it here just for illustratory putposes
}

void Dstar_ccbar::beginJob()
{
  Service<TFileService> fs; 
  decaytree = fs->make<TTree>("decaytree","decaytree");
  decaytree->Branch("eta_paifromdstar",&eta_paifromdstar,"eta_paifromdstar/D");
  dstarpt = fs->make<TH1D>(  "dstarpt", "Dstar pt", 100,  20., 300. ) ;
  fHist4muMass = fs->make<TH1D>(  "Hist4muMass", "4-mu inv. mass", 100, 170., 210. ) ;
  fHistZZMass  = fs->make<TH1D>(  "HistZZMass",  "ZZ inv. mass",   100, 170., 210. ) ;    
    
  return ;
  
}

void Dstar_ccbar::analyze( const Event& e, const EventSetup& )
{
  
  // here's an example of accessing GenEventInfoProduct
  Handle< GenEventInfoProduct > GenInfoHandle;
  e.getByLabel( "generator", GenInfoHandle );
  double qScale = GenInfoHandle->qScale();
  double pthat = ( GenInfoHandle->hasBinningValues() ? 
                  (GenInfoHandle->binningValues())[0] : 0.0);
//  cout << " qScale = " << qScale << " pthat = " << pthat << endl;
  //
  // this (commented out) code below just exemplifies how to access certain info 
  //
  //double evt_weight1 = GenInfoHandle->weights()[0]; // this is "stanrd Py6 evt weight;
                                                    // corresponds to PYINT1/VINT(97)
  //double evt_weight2 = GenInfoHandle->weights()[1]; // in case you run in CSA mode or otherwise
                                                    // use PYEVWT routine, this will be weight
						    // as returned by PYEVWT, i.e. PYINT1/VINT(99)
  //std::cout << " evt_weight1 = " << evt_weight1 << std::endl;
  //std::cout << " evt_weight2 = " << evt_weight2 << std::endl;
  //double weight = GenInfoHandle->weight();
  //std::cout << " as returned by the weight() method, integrated event weight = " << weight << std::endl;
  
  // here's an example of accessing particles in the event record (HepMCProduct)
  //
  Handle< HepMCProduct > EvtHandle ;
  
  // find initial (unsmeared, unfiltered,...) HepMCProduct
  //
  e.getByLabel( "generator", EvtHandle ) ;
  
  const HepMC::GenEvent* Evt = EvtHandle->GetEvent() ;
  
  // this a pointer - and not an array/vector/... 
  // because this example explicitely assumes
  // that there one and only Higgs in the record
  //
  HepMC::GenVertex* D0DecVtx = 0 ;

  int numberofdstar = 0;
  int numberofd0tokaipai = 0;
 
  
  Handle<GenParticleCollection> genParticles;
  e.getByLabel("genParticles", genParticles);
//  cout << "particle number = " << genParticles->size() << endl;


  for(size_t i = 0; i < genParticles->size(); ++ i) {
     const GenParticle & p = (*genParticles)[i];
     int id = p.pdgId();
     int st = p.status();  
     if (abs(id) != 413 || abs(st) != 2)   continue;
     numberofdstar++;
     const Candidate * mom1 = p.mother();
     const Candidate * mom = mom1->mother();
//     cout << "pid of mother's mother = " << (mom->mother())->pdgId() << endl;
//     const Candidate * ancester = p.();
//     double pt = p.pt(), eta = p.eta(), phi = p.phi(), mass = p.mass();
//     pt_dmeson = pt;
//     double vx = p.vx(), vy = p.vy(), vz = p.vz();
//     int charge = p.charge();
     int n = p.numberOfDaughters();
     if ( n != 2) continue;
     const Candidate * d0;
     const Candidate * pai;
     const Candidate * paionfromd0;
     const Candidate * kaionfromd0;
     if (!((p.daughter(0)->pdgId() == 421 && abs( p.daughter(1)->pdgId()) == 211) ||( abs(p.daughter(0)->pdgId()) == 221 &&  p.daughter(1)->pdgId() == 421)))   
           continue;
     if ( p.daughter(0)->pdgId() == 421 && abs( p.daughter(1)->pdgId()) == 211 )   { d0 = p.daughter(0); pai = p.daughter(1); }
     if ( abs(p.daughter(0)->pdgId()) == 221 &&  p.daughter(1)->pdgId() == 421 )   { d0 = p.daughter(1); pai = p.daughter(0); }
  //    cout << "Dstar to pai d0" << endl;
  //    cout << "D0 daughter number" << d0->numberOfDaughters()<<endl;
     if (!(d0->status() == 2 && d0->numberOfDaughters() == 2)) continue;
     if (!((abs(d0->daughter(0)->pdgId())==321&&abs(d0->daughter(1)->pdgId())==211)||(abs(d0->daughter(0)->pdgId())==211&&abs(d0->daughter(1)->pdgId())==321)))
           continue;
     if(d0->daughter(0)->pdgId() * d0->daughter(1)->pdgId() > 0)   continue;
     if(abs(d0->daughter(0)->pdgId())==321&&abs(d0->daughter(1)->pdgId())==211)   {  paionfromd0 = d0->daughter(1); kaionfromd0 = d0->daughter(0) ;}
     if(abs(d0->daughter(0)->pdgId())==211&&abs(d0->daughter(1)->pdgId())==321)   {  paionfromd0 = d0->daughter(0); kaionfromd0 = d0->daughter(1) ;}

     const Candidate * ddstar = &p;
     cout << "Dstar to D0 pai to pai kai pai" << endl;
     eta_paifromdstar = pai->eta();

 //    paifromdstar.pt = pai->pt();  paifromdstar.eta = pai->eta(); paifromdstar.phi = pai->phi(); paifromdstar.mass = pai->mass(); paifromdstar.pid = pai->pdgId(); paifromdstar.charge = pai->charge();

 //    kaifromd0.pt = kaionfromd0->pt();  kaifromd0.eta = kaionfromd0->eta(); kaifromd0.phi = kaionfromd0->phi(); kaifromd0.mass = kaionfromd0->mass(); kaifromd0.pid = kaionfromd0->pdgId(); kaifromd0.charge = kaionfromd0->charge();

//     cout << "kaion id" << kaifromd0.pid << "*************" << kaionfromd0->pdgId() << endl;

//     paifromd0.pt = paionfromd0->pt();  paifromd0.eta = paionfromd0->eta(); paifromd0.phi = paionfromd0->phi(); paifromd0.mass = paionfromd0->mass(); paifromd0.pid = paionfromd0->pdgId(); paifromd0.charge = paionfromd0->charge();

//     dstar.pt = ddstar->pt();  dstar.eta = ddstar->eta();dstar.phi = ddstar->phi(); dstar.mass = ddstar->mass(); dstar.pid = ddstar->pdgId(); dstar.charge = ddstar->charge();

//     d0fromdstar.pt = d0->pt();  d0fromdstar.eta = d0->eta(); d0fromdstar.phi = d0->phi(); d0fromdstar.mass = d0->mass(); d0fromdstar.pid = d0->pdgId(); d0fromdstar.charge = d0->charge();

//     dstarmother.pt = mom->pt();  dstarmother.eta = mom->eta(); dstarmother.phi = mom->phi(); dstarmother.mass = mom->mass(); dstarmother.pid = mom->pdgId(); dstarmother.charge = mom->charge();

  //   decaytree->Fill();
   }
 

   cout << "number of Dstar =====" << numberofdstar << endl;
  
   
   return ;
   
}

void Dstar_ccbar::endRun( const edm::Run& r, const edm::EventSetup& )
{

   return;

}


void Dstar_ccbar::endJob()
{
   
   return ;
}
 
typedef Dstar_ccbar Dstar_ccbar_Analyzer;
DEFINE_FWK_MODULE(Dstar_ccbar_Analyzer);
